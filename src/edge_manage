#!/usr/bin/env python

from edgemanage import const, EdgeTest, EdgeState, DecisionMaker, StateFile, EdgeList, VerifyFailed

from concurrent.futures import ProcessPoolExecutor, as_completed
import argparse
import fcntl
import glob
import hashlib
import json
import logging
import logging.handlers
import os
import pprint
import random
import subprocess
import sys
import time
import yaml

__author__="nosmo@nosmo.me"

# Make requests stop logging so much. I love you but you need to shut
# up.
requests_log = logging.getLogger("requests")
requests_log.setLevel(logging.WARNING)


def acquire_lock(lockfile):
    # Attempt to lock a file so that we don't have overlapping runs
    # Might be deperecated in future in favour of the time checking
    # used at the start of main()
    fp = open(lockfile, 'w')

    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        return False

    return True

def run_command_list(commands):
    for command in commands:
        # Subprocess wants a list. This will complicate things for
        # people using complex strings but for now that's too bad.
        command = command.split(" ")
        try:
            popened_p = subprocess.Popen(command)
        except OSError as e:
            logging.error("Failed to run command %s: %s", command, str(e))
        except Exception as e:
            # ~* I want to be the very best, like no one ever was *~
            # I'll allow this kind of exception handling here
            # because an unforeseen condition here shouldn't break
            # execution.
            logging.error(
                "Caught unhandled exception when running command %s: %s",
                command, str(e)
            )
        else:
            logging.info("Started execution of command without issue: %s", command)

    return None

def future_fetch(edgetest, testobject_host, testobject_path,
                 testobject_proto, testobject_verify):
    """Helper function to give us a return value that plays nice with as_completed"""

    try:
        fetch_result = edgetest.fetch(testobject_host, testobject_path,
                                      testobject_proto, testobject_verify)
    except VerifyFailed:
        fetch_result = False
    return {edgetest.edgename: fetch_result}

class EdgeManage(object):

    def _init_objects(self):
        # List of edges that will be made live
        self.edgelist_obj = EdgeList()
        # Object we will use to make a decision about edge liveness based
        # on the stat stores
        self.decision = DecisionMaker()

        self.edge_states = {}

        self.testobject_hash = self.get_testobject_hash()

    def get_testobject_hash(self):
        # Hash the local copy of the object to be requested from the edges
        with open(self.config["testobject"]["local"]) as test_local_f:
            testobject_hash = hashlib.md5(test_local_f.read()).hexdigest()
            logging.info("Hash of local object %s is %s",
                         config["testobject"]["local"], testobject_hash)

        return testobject_hash

    def __init__(self, dnet, config, state, dry_run=False):
        self.dnet = dnet
        self.dry_run = dry_run
        self.config = config
        self.state_obj = state

        self._init_objects()

    def add_edge_state(self, edge, edge_healthdata_path, nowrite=False):
        edge_state = EdgeState(edge, edge_healthdata_path, nowrite=nowrite)
        self.edge_states[edge] = edge_state

    def do_edge_tests(self):

        test_dict = self.config["testobject"]
        test_host = test_dict["host"]
        test_path = test_dict["uri"]
        test_proto = test_dict["proto"]
        test_verify = test_dict["verify"]

        edgescore_futures = []
        with ProcessPoolExecutor() as executor:
            for edgename in self.edge_states:
                edge_t = EdgeTest(edgename, self.testobject_hash)
                edgescore_futures.append(executor.submit(future_fetch,
                                                         edge_t, test_host,
                                                         test_path,
                                                         test_proto,
                                                         test_verify))

        verification_failues = []

        for f in as_completed(edgescore_futures):
            try:
                result = f.result()
            except Exception as e:
                # Do some shit here
                raise
            edge, value = result.items()[0]

            if value == False:
                verification_failues.append(edge)

            self.edge_states[edge].add_value(value)
            logging.info("Fetch time for %s: %f avg: %f",
                         edge, value,
                         self.edge_states[edge].current_average())

            # Skip edges that we have forced out of commission
            if self.edge_states[edge].mode == "unavailable":
                logging.debug("Skipping edge %s as its status has been set to unavailable", edge)
            else:
                # otherwise add it to the decision maker
                self.decision.add_edge_state(self.edge_states[edge])

        return verification_failues

    def check_last_live(self, state_obj):

        # A list of edges that were in use last time that are still
        # healthy now.
        still_healthy = []

        if state_obj.last_live:
            logging.debug("Live edge list from previous run is %s",
                          state_obj.last_live)

        # Make sure that any edges that were in rotation are still
        # in a passing state. Discard any that are failing checks.
        for oldlive_edge in state_obj.last_live:
            if oldlive_edge in self.decision.current_judgement and \
               self.decision.get_judgement(oldlive_edge) == "pass":
                still_healthy.append(oldlive_edge)
            elif oldlive_edge not in self.decision.current_judgement:
                logging.warning(("Discarding previously live edge %s "
                                 "because it is no longer being checked",),
                                oldlive_edge)
            else:
                logging.debug(
                    "Discarding previously live edge %s because it is in state %s",
                    oldlive_edge,
                    self.decision.current_judgement[oldlive_edge])

        return list(set(still_healthy))

    def make_edges_live(self, state_obj):

        good_enough = self.config["goodenough"]
        required_edge_count = self.config["edge_count"]

        threshold_stats = self.decision.check_threshold(good_enough)
        for edgename, edge_state in self.edge_states.iteritems():
            if edge_state.mode == "force":
                if self.decision.get_judgement(edgename) == "pass":
                    logging.debug(
                        "Making host %s live because it is in mode force and it is in state pass",
                        edgename)
                    self.edgelist_obj.add_edge(edgename, state="Pass", live=True)
            elif edge_state.mode == "blindforce":
                logging.debug("Making host %s live bceause it is in mode blindforce.",
                              edgename)
                self.edgelist_obj.add_edge(edgename, state="Pass", live=True)

        logging.debug("Stats of threshold check are %s", str(threshold_stats))

        # Do we have a previous edge list?
        still_healthy_from_last_run = self.check_last_live(state_obj)
        if still_healthy_from_last_run:
            logging.info("Got list of previously in use edges that are in a passing state: %s",
                         still_healthy_from_last_run)

        for still_healthy in still_healthy_from_last_run:
            if len(self.edgelist_obj) < required_edge_count:
                self.edgelist_obj.add_edge(still_healthy, state="pass", live=True)

        if len(still_healthy_from_last_run) == required_edge_count:
            logging.info(
                "Old edge list is still healthy - not making any changes"
            )
        else:
            logging.debug(("Didn't have enough healthy edges from last run to meet "
                           "edge count - trying to add more edges"))

            for decision_edge, edge_state in self.decision.current_judgement.iteritems():
                if decision_edge not in self.edgelist_obj.edges:
                    self.edgelist_obj.add_edge(decision_edge, state=edge_state)
            logging.debug("List of previously passing edges is currently %s",
                          self.edgelist_obj.get_live_edges())

            # Attempt to meet demand, first with passing, then with
            # window, then with average passing
            for desired_state in ["pass", "pass_window", "pass_average"]:
                filled_by_current_state = edgelist_obj.set_live_by_state(desired_state,
                                                                         required_edge_count)
                if filled_by_current_state:
                    logging.info("Filled requirement for %d edges with edges in state %s",
                                 required_edge_count, desired_state)
                    break
            else:
                # Entering an "else" in the context of a "for" loop means
                # "we didn't break". It's horrible but it's exactly what
                # we need here.
                logging.error("Tried to add edges from all acceptable states but failed")
                # TODO randomly try to add edges in a panic

        if self.edgelist_obj.get_live_count() == required_edge_count:
            logging.info("Successfully established %d edges: %s",
                         self.edgelist_obj.get_live_count(),
                         self.edgelist_obj.get_live_edges())

            # Iterate over every *zone file in the zonetemplate dir and write out files.
            zone_glob_path = "%s/%s/*.zone" % (self.config["zonetemplate_dir"], self.dnet)
            for zonefile in glob.glob(zone_glob_path):
                zone_name = zonefile.split(".zone")[0].split("/")[-1]
                complete_zone_str = self.edgelist_obj.generate_zone(
                    zone_name, os.path.join(config["zonetemplate_dir"], self.dnet),
                    self.config["dns"]
                )

                complete_zone_path = os.path.join(self.config["named_dir"],
                                                  "%s.zone" % zone_name)
                #TODO add rotation of old files
                if not self.dry_run:
                    with open(complete_zone_path, "w") as complete_zone_f:
                        logging.debug("Writing completed zone file for %s to %s",
                                      zone_name, complete_zone_path)
                        complete_zone_f.write(complete_zone_str)
                else:
                    logging.debug(("In dry run so not writing file %s for zone %s. "
                                   "It would have contained:\n%s"),
                                  complete_zone_path, zone_name, complete_zone_str)


        else:
            logging.error("Couldn't establish full edge list! Only have %d edges (%s), need %d",
                          self.edgelist_obj.get_live_count(),
                          self.edgelist_obj.get_live_edges(),
                          required_edge_count)

        # We've got our edges, one way or another - let's set their states
        # Note in the statefile that this edge has been put into rotation
        for edge in self.edge_states:
            if self.edgelist_obj.is_live(edge):
                logging.debug("Setting edge %s to state in", edge)
                self.edge_states[edge].add_rotation()
                self.edge_states[edge].set_state("in")
            else:
                logging.debug("Setting edge %s to state out", edge)
                self.edge_states[edge].set_state("out")

        #TODO
        return

def main(dnet, daemonise, dry_run, config, state_obj):

    edgemanage_object = EdgeManage(dnet, config, state, dry_run)

    # Read the edgelist as a flat file
    with open(os.path.join(config["edgelist_dir"], dnet)) as edge_f:
        edge_list = [ i.strip() for i in edge_f.read().split("\n") if i.strip() and not i.startswith("#") ]
        logging.info("Edge list is %s", str(edge_list))

    # Load or create our edge state files
    for edge in edge_list:
        edgemanage_object.add_edge_state(edge, config["healthdata_store"], nowrite=dry_run)

    # Run any run_before commands
    if "commands" in config and "run_before" in config["commands"]:
        if config["commands"]["run_before"]:
            run_command_list(config["commands"]["run_before"])

    verification_failues = edgemanage_object.do_edge_tests()
    state_obj.verification_failures = verification_failues

    edgemanage_object.make_edges_live(state_obj)

    if edgemanage_object.edgelist_obj.get_live_edges() != state_obj.last_live:
        # There has been a rotation as our old list doesn't equal the new
        state_obj.add_rotation(const.STATE_HISTORICAL_ROTATIONS)
    state_obj.last_live = edgemanage_object.edgelist_obj.get_live_edges()

    # Write out a flat list of live edges if the config file asks for it
    if "live_list" in config:
        livelist_path = config["live_list"]
        if "{dnet}" in livelist_path:
            livelist_path = livelist_path.format(dnet=dnet)

        with open(livelist_path, "w") as livelist_f:
            livelist_f.write("\n".join(
                edgemanage_object.edgelist_obj.get_live_edges()) + "\n")

    # Run any run_after commands
    if "commands" in config and "run_after" in config["commands"]:
        if config["commands"]["run_after"]:
            run_command_list(config["commands"]["run_after"])

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Manage Deflect edge status.')
    parser.add_argument("--dnet", "-A", dest="dnet", action="store",
                        help="Specify DNET",
                        required=True)
    parser.add_argument("--config", "-c", dest="config_path", action="store",
                        help="Path to configuration file (defaults to %s)" % const.CONFIG_PATH,
                        default=const.CONFIG_PATH)
    parser.add_argument("--dry-run", "-n", dest="dryrun", action="store_true",
                        help="Dry run - don't generate any files", default=False)
    parser.add_argument("--force", dest="force", action="store_true",
                        help="Force execution", default=False)
    parser.add_argument("--daemonise", dest="daemonise", action="store_true",
                        help="Run as a daemon, executing as often as is defined in config",
                        default=False)
    parser.add_argument("--verbose", "-v", dest="verbose", action="store_true",
                        help="Verbose output", default=False)
    args = parser.parse_args()

    with open(args.config_path) as config_f:
        config = yaml.safe_load(config_f.read())

    state = StateFile()
    if os.path.exists(config["statefile"]):
        with open(config["statefile"]) as statefile_f:
            state = StateFile(json.loads(statefile_f.read()))

    time_now = time.time()
    if state.last_run and not args.dryrun and \
       int(state.last_run) + 50 > int(time_now) and not args.force:
        logging.error(("Can't run - last run was %d, current time is %d. Bypass"
                       " this check at your own risk with --force"),
                      state.last_run, time_now)
        sys.exit(1)

    if args.verbose:
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler() # log to STDERR
        handler.setFormatter(
            logging.Formatter('edgemanage (%(process)d): %(levelname)s %(message)s')
        )
        logger.addHandler(handler)

    else:
        # Set up logging
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        logfile_handler = logging.handlers.WatchedFileHandler(config["logpath"])
        logfile_handler.setFormatter(logging.Formatter('edgemanage (%(process)d): %(levelname)s %(message)s'))
        #TODO setup logging for error level in another file
        logger.addHandler(logfile_handler)

    logging.debug("Command line options are %s", str(args))
    logging.debug("Full configuration is:\n %s", pprint.pformat(config))

    if not acquire_lock(config["lockfile"]):
        raise Exception("Couldn't acquire lock file - is Edgemanage running elsewhere?")
    else:
        main(args.dnet, args.daemonise, args.dryrun, config, state)
    state.set_last_run()
    if not args.dryrun:
        with open(config["statefile"], "w") as statefile_f:
            statefile_f.write(state.to_json())
