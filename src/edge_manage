#!/usr/bin/env python

from edgemanage import const, EdgeTest, StatStore, DecisionMaker, StateFile, EdgeList, VerifyFailed

from concurrent.futures import ProcessPoolExecutor, as_completed
import argparse
import fcntl
import glob
import hashlib
import json
import logging
import os
import pprint
import random
import subprocess
import sys
import time
import yaml

# Make requests stop logging so much. I love you but you need to shut
# up.
requests_log = logging.getLogger("requests")
requests_log.setLevel(logging.WARNING)

# TODO Wrap these functions and most of main in an object - everything
# is messy as fuck.

def check_last_live(state_obj, decision_obj):

    # A list of edges that were in use last time that are still
    # healthy now.
    still_healthy = []

    if state_obj.last_live:
        logging.debug("Live edge list from previous run is %s", state_obj.last_live)

    # Make sure that any edges that were in rotation are still
    # in a passing state. Discard any that are failing checks.
    for oldlive_edge in state_obj.last_live:
        if oldlive_edge in decision_obj.current_judgement and \
           decision_obj.current_judgement[oldlive_edge] == "pass":
            still_healthy.append(oldlive_edge)
        else:
            logging.debug("Discarding previously live edge %s because it is in state %s",
                          oldlive_edge,
                          decision_obj.current_judgement[oldlive_edge])

    return list(set(still_healthy))


def acquire_lock(lockfile):
    # Attempt to lock a file so that we don't have overlapping runs
    # Might be deperecated in future in favour of the time checking
    # used at the start of main()
    fp = open(lockfile, 'w')

    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        return False

    return True

def run_command_list(commands):
    for command in commands:
        # Subprocess wants a list. This will complicate things for
        # people using complex strings but for now that's too bad.
        command = command.split(" ")
        try:
            popened_p = subprocess.Popen(command)
        except OSError as e:
            logging.error("Failed to run command %s: %s", command, str(e))
        except Exception as e:
            # ~* I want to be the very best, like no one ever was *~
            # I'll allow this kind of exception handling here
            # because an unforeseen condition here shouldn't break
            # execution.
            logging.error(
                "Caught unhandled exception when running command %s: %s",
                command, str(e)
            )
        else:
            logging.info("Executed command %s successfully", command)

    return None

def future_fetch(edgetest, testobject_host, testobject_path,
                 testobject_proto, testobject_verify):
    """Helper function to give us a return value that plays nice with as_completed"""

    try:
        fetch_result = edgetest.fetch(testobject_host, testobject_path,
                                      testobject_proto, testobject_verify)
    except VerifyFailed:
        fetch_result = False
    return {edgetest.edgename: fetch_result}

def main(dnet, dry_run, config, state_obj):

    time_now = time.time()
    if state_obj.last_run and not dry_run and int(state_obj.last_run) + 59 > int(time_now):
        logging.error("Can't run - last run was %d, current time is %d",
                      state_obj.last_run, time_now)
        sys.exit(1)

    # Read the edgelist as a flat file
    with open(os.path.join(config["edgelist_dir"], dnet)) as edge_f:
        edge_list = [ i.strip() for i in edge_f.read().split("\n") if i.strip() and not i.startswith("#") ]
        logging.info("Edge list is %s", str(edge_list))

    testobject_proto = config["testobject"]["proto"]
    testobject_host = config["testobject"]["host"]
    testobject_path = config["testobject"]["uri"]
    testobject_verify = config["testobject"]["verify"]

    # Hash the local copy of the object to be requested from the edges
    with open(config["testobject"]["local"]) as test_local_f:
        testobject_hash = hashlib.md5(test_local_f.read()).hexdigest()
        logging.info("Hash of local object %s is %s",
                     config["testobject"]["local"], testobject_hash)

    # Run any run_before commands
    if "commands" in config and "run_before" in config["commands"]:
        if config["commands"]["run_before"]:
            run_command_list(config["commands"]["run_before"])

    edgescore_futures = []

    with ProcessPoolExecutor() as executor:
        for edgename in edge_list:
            edge_t = EdgeTest(edgename, testobject_hash)
            edgescore_futures.append(executor.submit(future_fetch,
                                                     edge_t, testobject_host,
                                                     testobject_path,
                                                     testobject_proto,
                                                     testobject_verify))

    decision = DecisionMaker()
    verification_failues = []

    for f in as_completed(edgescore_futures):
        try:
            result = f.result()
        except Exception as e:
            # Do some shit here
            raise
        edge, value = result.items()[0]

        if value == False:
            verification_failues.append(edge)

        stat_store = StatStore(edge, config["healthdata_store"], nowrite=dry_run)
        stat_store.add_value(value)
        logging.info("Fetch time for %s: %f avg: %f",
                     edge, value, stat_store.current_average())
        decision.add_stat_store(stat_store)
    threshold_stats = decision.check_threshold(config["goodenough"])
    state_obj.verification_failures = verification_failues
    logging.debug("Stats of threshold check are %s", str(threshold_stats))

    # List of edges that will be made live

    edgelist = EdgeList()

    # Do we have a previous edge list?
    still_healthy_from_last_run = check_last_live(state_obj, decision)
    if still_healthy_from_last_run:
        logging.info("Got list of previously in use edges that are in a passing state: %s",
                     still_healthy_from_last_run)

    for still_healthy in still_healthy_from_last_run:
        edgelist.add_edge(still_healthy, state="pass", live=True)

    if len(still_healthy_from_last_run) == config["edge_count"]:
        logging.info(
            "Old edge list is still healthy - not making any changes"
        )
    else:
        logging.debug(("Didn't have enough healthy edges from last run to meet "
                      "edge count - trying to add more edges"))

        for decision_edge, edge_state in decision.current_judgement.iteritems():
            if decision_edge not in edgelist.edges:
                edgelist.add_edge(decision_edge, state=edge_state)
        logging.debug("List of previously passing edges is currently %s", edgelist.get_live_edges())

        #if len(edgelist.get_edges("pass")) < config["edge_count"]:
        #    logging.warning(("Don't have enough passing edges to supply a full "
        #                     "list! (%d in pass state, %d healthy from last run)"),
        #                    config["edge_count"], len(edgelist.get_edges("pass")))


        # Attempt to meet demand, first with passing, then with
        # window, then with average passing
        for state in ["pass", "pass_window", "pass_average"]:
            filled_by_current_state = edgelist.set_live_by_state(state, config["edge_count"])
            if filled_by_current_state:
                logging.info("Filled requirement for %d edges with edges in state %s", config["edge_count"], state)
                break
        else:
            # Entering an "else" in the context of a "for" loop means
            # "we didn't break". It's horrible but it's exactly what
            # we need here.
            logging.error("Tried to add edges from all acceptable states but failed")
            # TODO randomly try to add edges in a panic

    if edgelist.get_live_count() == config["edge_count"]:
        logging.info("Successfully established %d edges: %s",
                     edgelist.get_live_count(), edgelist.get_live_edges())

        # Iterate over every *zone file in the zonetemplate dir and write out files.
        for zonefile in glob.glob("%s/%s/*.zone" % (config["zonetemplate_dir"], dnet)):
            zone_name = zonefile.split(".zone")[0].split("/")[-1]
            complete_zone_str = edgelist.generate_zone(
                zone_name, os.path.join(config["zonetemplate_dir"], dnet),
                config["dns"]
            )

            complete_zone_path = os.path.join(config["named_dir"], "%s.zone" % zone_name)
            #TODO add rotation of old files
            if not dry_run:
                with open(complete_zone_path, "w") as complete_zone_f:
                    logging.debug("Writing completed zone file for %s to %s",
                                  zone_name, complete_zone_path)
                    complete_zone_f.write(complete_zone_str)
            else:
                logging.debug(("In dry run so not writing file %s for zone %s. "
                               "It would have contained:\n%s"),
                              complete_zone_path, zone_name, complete_zone_str)

        # There has been a rotation as our old list doesn't equal the new
        if edgelist.get_live_edges() != state_obj.last_live:
            state_obj.add_rotation(const.STATE_HISTORICAL_ROTATIONS)
        state_obj.last_live = edgelist.get_live_edges()

        if "live_list" in config:
            livelist_path = config["live_list"]
            if "{dnet}" in livelist_path:
                livelist_path = livelist_path.format(dnet=dnet)

            with open(livelist_path, "w") as livelist_f:
                livelist_f.write("\n".join(edgelist.get_live_edges()) + "\n")

    else:
        logging.error("Couldn't establish full edge list! Only have %d edges (%s), need %d",
                      edgelist.get_live_count(), edgelist.get_live_edges(), config["edge_count"])
        state_obj.add_rotation(const.STATE_HISTORICAL_ROTATIONS)
        state_obj.last_live = edgelist.get_live_edges()

    if "commands" in config and "run_after" in config["commands"]:
        if config["commands"]["run_after"]:
            run_command_list(config["commands"]["run_after"])

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Manage Deflect edge status.')
    parser.add_argument("--dnet", "-A", dest="dnet", action="store",
                        help="Specify DNET (mandatory)")
    parser.add_argument("--config", "-c", dest="config_path", action="store",
                        help="Path to configuration file (defaults to %s)" % const.CONFIG_PATH,
                        default=const.CONFIG_PATH)
    parser.add_argument("--dry-run", "-n", dest="dryrun", action="store_true",
                        help="Dry run - don't generate any files", default=False)
    parser.add_argument("--verbose", "-v", dest="verbose", action="store_true",
                        help="Verbose output", default=False)
    args = parser.parse_args()

    with open(args.config_path) as config_f:
        config = yaml.safe_load(config_f.read())

    if args.verbose:
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler() # log to STDERR
        handler.setFormatter(
            logging.Formatter('edgemanage [%(process)d] %(levelname)s %(message)s')
        )
        logger.addHandler(handler)

    logging.debug("Command line options are %s", str(args))
    logging.debug("Full configuration is:\n %s", pprint.pformat(config))

    if not args.dnet:
        raise AttributeError("DNET is a mandatory option")

    state = StateFile()
    if os.path.exists(config["statefile"]):
        with open(config["statefile"]) as statefile_f:
            state = StateFile(json.loads(statefile_f.read()))

    if not acquire_lock(config["lockfile"]):
        raise Exception("Couldn't acquire lock file - is Edgemanage running elsewhere?")
    else:
        main(args.dnet, args.dryrun, config, state)
    state.set_last_run()
    if not args.dryrun:
        with open(config["statefile"], "w") as statefile_f:
            statefile_f.write(state.to_json())
