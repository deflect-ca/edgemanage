#!/usr/bin/env python

from edgemanage import const, EdgeTest, EdgeState, DecisionMaker, StateFile, EdgeList, VerifyFailed

from concurrent.futures import ProcessPoolExecutor, as_completed
import argparse
import fcntl
import glob
import hashlib
import json
import logging
import logging.handlers
import os
import pprint
import random
import subprocess
import sys
import time
import yaml

__author__="nosmo@nosmo.me"

# Make requests stop logging so much. I love you but you need to shut
# up.
requests_log = logging.getLogger("requests")
requests_log.setLevel(logging.WARNING)

# TODO Wrap these functions and most of main in an object - everything
# is messy as fuck.

def check_last_live(state_obj, decision_obj):

    # A list of edges that were in use last time that are still
    # healthy now.
    still_healthy = []

    if state_obj.last_live:
        logging.debug("Live edge list from previous run is %s",
                      state_obj.last_live)

    # Make sure that any edges that were in rotation are still
    # in a passing state. Discard any that are failing checks.
    for oldlive_edge in state_obj.last_live:
        if oldlive_edge in decision_obj.current_judgement and \
           decision_obj.get_judgement(oldlive_edge) == "pass":
            still_healthy.append(oldlive_edge)
        elif oldlive_edge not in decision_obj.current_judgement:
            logging.warning(("Discarding previously live edge %s "
                             "because it is no longer being checked",),
                            oldlive_edge)
        else:
            logging.debug(
                "Discarding previously live edge %s because it is in state %s",
                oldlive_edge,
                decision_obj.current_judgement[oldlive_edge])

    return list(set(still_healthy))


def acquire_lock(lockfile):
    # Attempt to lock a file so that we don't have overlapping runs
    # Might be deperecated in future in favour of the time checking
    # used at the start of main()
    fp = open(lockfile, 'w')

    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        return False

    return True

def run_command_list(commands):
    for command in commands:
        # Subprocess wants a list. This will complicate things for
        # people using complex strings but for now that's too bad.
        command = command.split(" ")
        try:
            popened_p = subprocess.Popen(command)
        except OSError as e:
            logging.error("Failed to run command %s: %s", command, str(e))
        except Exception as e:
            # ~* I want to be the very best, like no one ever was *~
            # I'll allow this kind of exception handling here
            # because an unforeseen condition here shouldn't break
            # execution.
            logging.error(
                "Caught unhandled exception when running command %s: %s",
                command, str(e)
            )
        else:
            logging.info("Started execution of command without issue: %s", command)

    return None

def future_fetch(edgetest, testobject_host, testobject_path,
                 testobject_proto, testobject_verify):
    """Helper function to give us a return value that plays nice with as_completed"""

    try:
        fetch_result = edgetest.fetch(testobject_host, testobject_path,
                                      testobject_proto, testobject_verify)
    except VerifyFailed:
        fetch_result = False
    return {edgetest.edgename: fetch_result}

def main(dnet, dry_run, config, state_obj):

    # List of edges that will be made live
    edgelist_obj = EdgeList()
    edge_states = {}
    # Object we will use to make a decision about edge liveness based
    # on the stat stores
    decision = DecisionMaker()

    # Read the edgelist as a flat file
    with open(os.path.join(config["edgelist_dir"], dnet)) as edge_f:
        edge_list = [ i.strip() for i in edge_f.read().split("\n") if i.strip() and not i.startswith("#") ]
        logging.info("Edge list is %s", str(edge_list))

    # Get a complete list of zone names
    zone_names = []
    current_mtimes = {}
    for zonefile in glob.glob("%s/%s/*.zone" % (config["zonetemplate_dir"], dnet)):
        zone_name = zonefile.split(".zone")[0].split("/")[-1]
        zone_names.append(zone_name)
        # And while we're here, let's get their mtimes
        current_mtime = int(os.stat(zonefile).st_mtime)
        current_mtimes[zone_name] = current_mtime

    # Load or create our edge state files
    for edge in edge_list:
        edge_state = EdgeState(edge, config["healthdata_store"], nowrite=dry_run)
        edge_states[edge] = edge_state

    testobject_proto = config["testobject"]["proto"]
    testobject_host = config["testobject"]["host"]
    testobject_path = config["testobject"]["uri"]
    testobject_verify = config["testobject"]["verify"]

    # Hash the local copy of the object to be requested from the edges
    with open(config["testobject"]["local"]) as test_local_f:
        testobject_hash = hashlib.md5(test_local_f.read()).hexdigest()
        logging.info("Hash of local object %s is %s",
                     config["testobject"]["local"], testobject_hash)

    # Run any run_before commands
    if "commands" in config and "run_before" in config["commands"]:
        if config["commands"]["run_before"]:
            run_command_list(config["commands"]["run_before"])

    edgescore_futures = []

    with ProcessPoolExecutor() as executor:
        for edgename in edge_list:
            edge_t = EdgeTest(edgename, testobject_hash)
            edgescore_futures.append(executor.submit(future_fetch,
                                                     edge_t, testobject_host,
                                                     testobject_path,
                                                     testobject_proto,
                                                     testobject_verify))

    verification_failues = []

    for f in as_completed(edgescore_futures):
        try:
            result = f.result()
        except Exception as e:
            # Do some shit here
            raise
        edge, value = result.items()[0]

        if value == False:
            verification_failues.append(edge)

        edge_states[edge].add_value(value)
        logging.info("Fetch time for %s: %f avg: %f",
                     edge, value, edge_states[edge].current_average())

        # Skip edges that we have forced out of commission
        if edge_states[edge].mode == "unavailable":
            logging.debug("Skipping edge %s as its status has been set to unavailable", edge)
        else:
            # otherwise add it to the decision maker
            decision.add_edge_state(edge_states[edge])

    threshold_stats = decision.check_threshold(config["goodenough"])
    for edgename, edge_state in edge_states.iteritems():
        if edge_state.mode == "force":
            if decision.get_judgement(edgename) == "pass":
                logging.debug("Making host %s live because it is in mode force and it is in state pass", edgename)
                edgelist_obj.add_edge(edgename, state="Pass", live=True)
        elif edge_state.mode == "blindforce":
            logging.debug("Making host %s live bceause it is in mode blindforce.", edgename)
            edgelist_obj.add_edge(edgename, state="Pass", live=True)

    state_obj.verification_failures = verification_failues
    logging.debug("Stats of threshold check are %s", str(threshold_stats))

    edgelist_changed = None

    # Do we have a previous edge list?
    still_healthy_from_last_run = check_last_live(state_obj, decision)
    if still_healthy_from_last_run:
        edgelist_changed = False
        logging.info("Got list of previously in use edges that are in a passing state: %s",
                     still_healthy_from_last_run)

    for still_healthy in still_healthy_from_last_run:
        if len(edgelist_obj) < config["edge_count"]:
            edgelist_obj.add_edge(still_healthy, state="pass", live=True)

    if len(still_healthy_from_last_run) == config["edge_count"]:
        logging.info(
            "Old edge list is still healthy - not making any changes"
        )
    else:
        logging.debug(("Didn't have enough healthy edges from last run to meet "
                      "edge count - trying to add more edges"))
        edgelist_changed = True

        for decision_edge, edge_state in decision.current_judgement.iteritems():
            if decision_edge not in edgelist_obj.edges:
                edgelist_obj.add_edge(decision_edge, state=edge_state)
        logging.debug("List of previously passing edges is currently %s", edgelist_obj.get_live_edges())

        # Attempt to meet demand, first with passing, then with
        # window, then with average passing
        for state in ["pass", "pass_window", "pass_average"]:
            filled_by_current_state = edgelist_obj.set_live_by_state(state, config["edge_count"])
            if filled_by_current_state:
                logging.info("Filled requirement for %d edges with edges in state %s", config["edge_count"], state)
                break
        else:
            # Entering an "else" in the context of a "for" loop means
            # "we didn't break". It's horrible but it's exactly what
            # we need here.
            logging.error("Tried to add edges from all acceptable states but failed")
            # TODO randomly try to add edges in a panic

    if edgelist_obj.get_live_count() == config["edge_count"]:
        logging.info("Successfully established %d edges: %s",
                     edgelist_obj.get_live_count(), edgelist_obj.get_live_edges())

        # Write out every qualifying zone file
        for zone_name in zone_names:

            # * Skip files that haven't been changed
            # * Write out zone files we haven't seen before
            # * don't write out updated zone files when we aren't changing edge list
            old_mtime = state_obj.zone_mtimes.get(zone_name)
            if not edgelist_changed and old_mtime and old_mtime == current_mtimes[zone_name]:
                logging.info("Not writing zonefile for %s because there are no changes pending", zone_name)
                continue

            complete_zone_str = edgelist_obj.generate_zone(
                zone_name, os.path.join(config["zonetemplate_dir"], dnet),
                config["dns"]
            )

            complete_zone_path = os.path.join(config["named_dir"], "%s.zone" % zone_name)
            #TODO add rotation of old files
            if not dry_run:
                with open(complete_zone_path, "w") as complete_zone_f:
                    logging.debug("Writing completed zone file for %s to %s",
                                  zone_name, complete_zone_path)
                    complete_zone_f.write(complete_zone_str)
            else:
                logging.debug(("In dry run so not writing file %s for zone %s. "
                               "It would have contained:\n%s"),
                              complete_zone_path, zone_name, complete_zone_str)

        # There has been a rotation as our old list doesn't equal the new
        if edgelist_obj.get_live_edges() != state_obj.last_live:
            state_obj.add_rotation(const.STATE_HISTORICAL_ROTATIONS)
        state_obj.last_live = edgelist_obj.get_live_edges()

        if "live_list" in config:
            livelist_path = config["live_list"]
            if "{dnet}" in livelist_path:
                livelist_path = livelist_path.format(dnet=dnet)

            with open(livelist_path, "w") as livelist_f:
                livelist_f.write("\n".join(edgelist_obj.get_live_edges()) + "\n")

    else:
        logging.error("Couldn't establish full edge list! Only have %d edges (%s), need %d",
                      edgelist_obj.get_live_count(), edgelist_obj.get_live_edges(), config["edge_count"])
        state_obj.add_rotation(const.STATE_HISTORICAL_ROTATIONS)
        state_obj.last_live = edgelist_obj.get_live_edges()

    # We've got our edges, one way or another - let's set their states
    for edge in edge_list:
        if edgelist_obj.is_live(edge):
            # Note in the statefile that this edge has been put into rotation
            logging.debug("Setting edge %s to state in", edge)
            edge_states[edge].add_rotation()
            edge_states[edge].set_state("in")
        else:
            logging.debug("Setting edge %s to state out", edge)
            edge_states[edge].set_state("out")

    state_obj.zone_mtimes = current_mtimes

    if "commands" in config and "run_after" in config["commands"]:
        if config["commands"]["run_after"]:
            run_command_list(config["commands"]["run_after"])

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Manage Deflect edge status.')
    parser.add_argument("--dnet", "-A", dest="dnet", action="store",
                        help="Specify DNET",
                        required=True)
    parser.add_argument("--config", "-c", dest="config_path", action="store",
                        help="Path to configuration file (defaults to %s)" % const.CONFIG_PATH,
                        default=const.CONFIG_PATH)
    parser.add_argument("--dry-run", "-n", dest="dryrun", action="store_true",
                        help="Dry run - don't generate any files", default=False)
    parser.add_argument("--force", dest="force", action="store_true",
                        help="Force execution", default=False)
    parser.add_argument("--verbose", "-v", dest="verbose", action="store_true",
                        help="Verbose output", default=False)
    args = parser.parse_args()

    with open(args.config_path) as config_f:
        config = yaml.safe_load(config_f.read())

    state = StateFile()
    if os.path.exists(config["statefile"]):
        with open(config["statefile"]) as statefile_f:
            state = StateFile(json.loads(statefile_f.read()))

    time_now = time.time()
    if state.last_run and not args.dryrun and \
       int(state.last_run) + 50 > int(time_now) and not args.force:
        logging.error(("Can't run - last run was %d, current time is %d. Bypass"
                       " this check at your own risk with --force"),
                      state.last_run, time_now)
        sys.exit(1)

    if args.verbose:
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler() # log to STDERR
        handler.setFormatter(
            logging.Formatter('edgemanage (%(process)d): %(levelname)s %(message)s')
        )
        logger.addHandler(handler)

    else:
        # Set up logging
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        logfile_handler = logging.handlers.WatchedFileHandler(config["logpath"])
        logfile_handler.setFormatter(logging.Formatter('edgemanage (%(process)d): %(levelname)s %(message)s'))
        #TODO setup logging for error level in another file
        logger.addHandler(logfile_handler)

    logging.debug("Command line options are %s", str(args))
    logging.debug("Full configuration is:\n %s", pprint.pformat(config))

    if not acquire_lock(config["lockfile"]):
        raise Exception("Couldn't acquire lock file - is Edgemanage running elsewhere?")
    else:
        main(args.dnet, args.dryrun, config, state)
    state.set_last_run()
    if not args.dryrun:
        with open(config["statefile"], "w") as statefile_f:
            statefile_f.write(state.to_json())
